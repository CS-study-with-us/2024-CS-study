객체와 관계형 DB 매핑

영속성 컨텍스트

JPA가 제공하는 기능은 엔티티와 테이블을 매핑하는 설계 부분과 매핑한 엔티티를 실제 사용하는 부분으로 나눔

엔티티 매니저: 엔티티를 저장, 수정, 삭제 조회 구성

엔티티 매니저 팩토리: 엔티티 매니저를 만드는 공장, 애플리케이션 전체에서 공유

엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전

But 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성문제 발생

JPA는 public 또는 protected 의 기본 생성자는 필수. 꼭 넣어 줘야함

JPA 구현 라이브러리가 객체를 생성할 때 리플랙션 같은 기술을 사용할 수 있도록 지원

JPA 의 모든 기능은 트랜잭션 안에서 처리

## 영속성 컨테스트

엔티티를 영구 저장하는 환경

엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관

비영속: 영속성 컨텍스트와 DB와 관련이 없음

영속: 영속성 컨텍스트가 관리하는 엔티티

### 영속성 컨텍스트의 특징

영속성 컨텍스트와 식별자 값: 엔티티를 식별자 값으로 구분⇒ 식별자 값이 반드시 있어야함

영속성 컨텍스트의 DB 저장: JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영 ⇒ 플러시(flush)라 함

플러시(flush): 영속성 컨텍스트의 변경 내용을 DB에 반영

영속성 컨텍스트의 장점

### 1차 캐시

영속성 컨텍스트는 내부에 캐시를 가지고 있음

영속 상태의 엔티티는 모두 이곳에 저장, 키는 @id로 매핑한 식별자고 값은 엔티티 인스턴스

em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 1차캐시에 없으면 DB에 조회함

⇒ DB에 조회한 데이터를로 엔티티를 생성해서 1차캐시에 저장해놈

동일성 보장:  같은 엔티티 인스턴스를 조회하면 같은 엔티티 인스턴스를 반환한다

동일성이란?

실제 인스턴스가 같다. 따라서 참조 값을 비교하는 ==비교의 값이 같다

동등성이란?

실제 인스턴스는 다를 수 잆지만 인스턴스가 가지고 있는 값이 같다 ⇒ 자바의 equals() 메소드 구현

### 쓰기 지연

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다. 또한  1차 캐시에서 엔티티를 저장함

⇒트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이것을 쓰기 지연이라 함

쓰기지연을 하는이유

데이터베이스에 한 번에 전달해서 성능을 최적화 할 수 있음

### 변경 감지

엔티티의 변경사항을 DB에 자동으로 반영함

JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해 저장 ⇒ 스냅샷이라함

플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾음

순서

1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출
2. 엔티티와 스냅샷을 비교해 변경된 엔티티를 찾음
3. 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보냄
4. DB에 보내서 커밋

변경 감지의 단점

엔티티의 모든 필드를 업데이트 해서 DB에 보내는 데이터 전송량이 증가하는 단점이있음

지연 로딩

영속성 컨테스트로 변환되지는 않음

## 준영속 엔티티

영속성 컨테스트에서 관리하지 않은 엔티티

엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 봄

하는 이유

모든 엔티티를 항상 영속 상태로 유지하면 메모리나 리소스를 과도하게 사용할 수 있음

트랜잭션이 끝난 후에도 엔티티 객체를 계속 사용할 수 있도록 하면서도, 데이터베이스에 자동으로 변경사항이 반영되지 않도록 하기 위함

수정 방법

변경 감지 기능

병합 사용 -머지 호출 → 1차 캐시 엔티티 찾기 → member 엔티티의 값을 채워 넣음

병합 값이 null이라면 모든 값을 null로 변환

## 엔티티 매핑

객체와 테이블 매핑:@Entity, @Table

### @Entity

JPA가 사용하는 객체라는 뜻, 기본 생성자는 필수, 저장한 필드는 final 사용 X, 엔티티 이름 지정해야함

### @Table

엔티티와 매핑할 테이블을 지정

### @Id

테이블의 PK와 해당 필드를 매핑, 기본 키 매핑

기본 키를 선택하는 전략

자연키- 비즈니스에 의미가 있는 키 ex) 주민등록번호 ,이메일 ,전화번호

대리 키- 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불림 ex) auto_increment

@Id 적용 가능 자바 타입

자바 기본형, 자바 래퍼형, String ,Date 등등

데이터베이스마다 기본 키를 생성하는 방식이 서로 다름

JPA가 제공하는 기본 키 생성 전략

직접 할당

기본 키를 애플리케이션에서 직접 할당

⇒ em.persist() 로 엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당해야함

식별자 값없이 저장하면 예외가 발생 ⇒ IdentifierGenerationException

자동 생성

대리키 사용 방식

@GeneratedValue(straregy=GenerationType.IDENTITY): PK 생성값을  DB에 위임

AUTO_INCREMENT를 사용한 예제처럼 DB 값을 저장하고 나서야 사용

IDENTITY 전략을 사용하는경우 em.persist()를 호출하는 즉시 INSERT SQL이 DB에 전달

⇒쓰기 지연이 동작하지 않음

@GeneratedValue(straregy=GenerationType.SEQUENCE): DB 시퀀스를 사용해서 기본 키를 할당

### @Column

객체의 필드를 테이블 컬럼과 매핑

@Enumerated

자바의 enum을 사용

STRING: enum이름을 DB에 저장,

ORDINAL: enum 순서를 DB에 저장

STRING 을 사용하자!

@Temporal

TemporalType.DATE:  DB date 타입

TemporalType.TIME:  DB time 타입

TemporalType.TIMESTAMP: 날짜와 시간, DB의 timestamp 타입과 매핑

@Lob

데이터베이스 BLOB, CLOB

## 스키마 자동 생성

[hibernate.auto](http://hibernate.auto):create 기존 테이블 삭제후 다시 생성

[hibernate.auto](http://hibernate.auto):create-drop 생성후 테이블 드랍

[hibernate.auto](http://hibernate.auto):update 변경 부분만 반영

## 엔티티 설계시 주의점

엔티티에서는 가급적 Setter를 사용하지 말자 ⇒ 변경 포인트가 너무 많아서, 유지보수가 어려움

모든 연관관계는 지연로딩으로 설정

즉시로딩은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어려움

실무에서 모든 연관관계는 지연로딩으로 설정

XToOne() default =EARER, 나머진 LAZY

⇒ 다 LAZY로 바꾸자

컬렉션은 필드에서 초기화 하자

null 문제에서 안전하다

하이버네이트는 엔티티를 영속화 할 때, 컬랙션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경

api를 만들때 절대 Entity를 반환하면 안됨

불안전한 api가 됨 , 외부에 보여주지 못하는 것을 보여주게 됨 ex)password

응답 스펙을 맞추기 위해 로직이 추가된다
)